// Generated by CoffeeScript 1.9.3
(function() {
    var AppBundleInfo, bplist, cgbiToPng, iOSAppBundleInfo, plist, PNGReader;

    plist = require('plist');

    bplist = require('bplist');

    var IpaReader = {};

    function _entityToBuffer(entity, arrayBuffer) {
        var deferred = $.Deferred();
        entity.getData(new zip.BlobWriter(entity), function(blob) {
            var reader = new FileReader();
            reader.onload = function() {
                if (!arrayBuffer) {
                    deferred.resolve(new Buffer(new Int8Array(reader.result)));
                } else {
                    deferred.resolve(reader.result);
                }
            };
            reader.onerror = function(e) {
                deferred.reject(e);
            };
            reader.readAsArrayBuffer(blob);
        });
        return deferred.promise();
    }

    var getFileMap = function(blob) {
        var deferred = $.Deferred();
        zip.createReader(new zip.BlobReader(blob), function(reader) {
            var fileMap = {};
            reader.getEntries(function(entries) {
                entries.forEach(function(entry) {
                    fileMap[entry.filename] = entry;
                });
                deferred.resolve(reader, fileMap);
            });
        }, function(error) {
            deferred.reject(error)
        });
        return deferred.promise();
    };

    var getPlist = function(fileMap) {
        var plistEntry,
            deferred = $.Deferred();
        reg = /^Payload\/.+\.app\/Info\.plist/;
        $.each(fileMap, function(path, entry) {
            if (reg.test(path)) {
                plistEntry = entry;
            }
        });

        if (!plistEntry) {
            deferred.reject("plist entiry not found!");
            return deferred.promise();
        }

        _entityToBuffer(plistEntry).then(function(plistBuffer) {
            if ('bplist00' !== plistBuffer.slice(0, 8).toString('ascii')) {
                try {
                    deferred.resolve(plist.parse(plistBuffer.toString('utf-8')));
                } catch (_error) {
                    deferred.reject(deferred);
                }
            } else {
                return bplist.parseBuffer(plistBuffer, function(err, result) {
                    if (err) {
                        deferred.reject(err);
                    } else {
                        deferred.resolve(result[0]);
                    }
                });
            }
        });

        return deferred.promise();

    }

    var getMobileProvision = function(fileMap) {
        var plistEntry,
            deferred = $.Deferred();
        reg = /^Payload\/.+\.app\/embedded\.mobileprovision/;
        $.each(fileMap, function(path, entry) {
            if (reg.test(path)) {
                plistEntry = entry;
            }
        });

        if (!plistEntry) {
            deferred.resolve();
            return deferred.promise();
        }

        plistEntry.getData(new zip.TextWriter(), function(text) {
            text = text.match(/<\?xml[^]+<\/plist>/gm)[0];
            try {
                deferred.resolve(plist.parse(text));
            } catch (_error) {
                deferred.reject(deferred);
            }
        });

        return deferred.promise();

    }


    var getIconBlob = function(fileMap, plist) {
        var iconEntry,
            deferred = $.Deferred();
        reg = /^Payload\/.+\.app\/AppIcon60x60@.+\.png/;
        $.each(fileMap, function(path, entry) {
            if (reg.test(path)) {
                iconEntry = entry;
            }
        });

        //如果找不到icon则取plist iconfiles定义的文件名
        if (!iconEntry) {
            var icons = plist.CFBundleIconFiles;
            if (icons && icons.length) {
                reg = new RegExp("^Payload\/.+\.app\/" + (icons[1] || icons[0]));
                $.each(fileMap, function(path, entry) {
                    if (reg.test(path)) {
                        iconEntry = entry;
                    }
                });
            }
        }

        if (!iconEntry) {
            deferred.resolve();
            return deferred.promise();
        }

        _entityToBuffer(iconEntry, true).then(function(iconBuffer) {
            var reader = new window.PNGReader(iconBuffer);
            reader.parse(function(error, png) {
                if (error) {
                    deferred.resolve();
                    return;
                }
                _checkImageIsAvaliable(_b64toBlob(_pngToBase64(png).substring(22), "image/png"));
            });
        });

        function _pngToBase64(png) {
            var w = png.width,
                h = png.height,
                canvas = $("<canvas>").attr({
                    width: w,
                    height: h
                })[0],
                ctx = canvas.getContext("2d");

            var imgData = ctx.getImageData(0, 0, w, h);
            var pixelIndex = 0;
            //canvas按照先x轴再y轴的顺序绘制，故y轴为第一层嵌套，x轴为第二次嵌套
            for (var y = 0; y < h; y++) {
                for (var x = 0; x < w; x++) {
                    var pixel = png.getPixel(x, y);
                    imgData.data[pixelIndex++] = pixel[0];
                    imgData.data[pixelIndex++] = pixel[1];
                    imgData.data[pixelIndex++] = pixel[2];
                    imgData.data[pixelIndex++] = pixel[3];
                }
            }

            ctx.putImageData(imgData, 0, 0);
            return canvas.toDataURL();
        }

        function _checkImageIsAvaliable(iconBlob) {
            var image = new Image();

            image.onload = function() {
                deferred.resolve(iconBlob);
            }

            image.onerror = function() {
                deferred.resolve(null);
            }

            image.src = window.URL.createObjectURL(iconBlob);
        }

        function _b64toBlob(b64Data, contentType, sliceSize) {
            contentType = contentType || '';
            sliceSize = sliceSize || 512;

            var byteCharacters = atob(b64Data);
            var byteArrays = [];

            for (var offset = 0; offset < byteCharacters.length; offset += sliceSize) {
                var slice = byteCharacters.slice(offset, offset + sliceSize);

                var byteNumbers = new Array(slice.length);
                for (var i = 0; i < slice.length; i++) {
                    byteNumbers[i] = slice.charCodeAt(i);
                }

                var byteArray = new Uint8Array(byteNumbers);

                byteArrays.push(byteArray);
            }

            var blob = new Blob(byteArrays, { type: contentType });
            return blob;
        }

        return deferred.promise();
    }

    IpaReader.getIpaInfo = function(blob) {
        var deferred = $.Deferred();
        getFileMap(blob)
            .done(function(reader, fileMap) {
                getPlist(fileMap).done(function(plist) {
                    getIconBlob(fileMap, plist)
                        .done(function(iconBlob) {
                            plist.iconBlob = iconBlob;
                            getMobileProvision(fileMap).done(function(provision) {
                                if (provision && provision.ProvisionsAllDevices) {
                                    plist.releaseType = "inhouse"
                                } else if (provision && provision.ProvisionedDevices) {
                                    plist.releaseType = "adhoc";
                                    plist.udids = provision.ProvisionedDevices
                                } else {
                                    plist.releaseType = "appstore";
                                }
                                deferred.resolve(plist);
                            }).fail(function(err) {
                                deferred.reject(err);
                            }).always(function() {
                                reader.close();
                            });
                        }).fail(function(err) {
                            deferred.reject(err);
                        })
                }).fail(function(err) {
                    deferred.reject(err);
                })
            })
            .fail(function(error) {
                deferred.reject(error);
            });
        return deferred.promise();
    }


    module.exports = IpaReader;

})();
